# Genetic Algorithm Solver

This project implements a Genetic Algorithm (GA) to solve an optimization problem involving the scheduling of libraries and book scanning, inspired by competitive programming challenges like Google Hash Code. The algorithm evolves a population of candidate solutions using standard genetic operations along with local search via hill climbing.

## Features

- **Population-based search** using genetic principles.
- **Elitism** to preserve the best solution across generations.
- **Tournament selection** to choose high-quality parents.
- **Crossover** combines library sequences from two parents.
- **Mutation** applies hill climbing to locally improve offspring.
- Automatically handles initialization and fitness evaluation.

## How It Works

1. **Initialization**: The algorithm creates an initial population by applying small hill climbing mutations to the given initial solution.
2. **Selection**: It uses tournament selection to choose parent solutions based on fitness.
3. **Crossover**: Offspring solutions are generated by combining the library signing order from both parents, avoiding duplication.
4. **Mutation**: Each offspring may be further optimized using a hill climbing method.
5. **Evolution**: This process is repeated for a fixed number of generations, with the best solution carried over each time (elitism).

## Parameters

- `population_size`: Number of individuals in the population (default: 50).
- `tournament_size`: Number of candidates in tournament selection (default: 10).
- `mutation_prob`: Probability of mutation for each child (default: 1.0).
- `hill_climbing_steps`: Number of steps for hill climbing during mutation (default: 100).

## Usage

```python
solver = GeneticAlgorithmSolver(instance_data, initial_solution)
best_solution = solver.solve()
```

## Requirements- Python 3.x
- A valid `InstanceData` and `Solution` object